// Generated by eXtraCoffeeScript 1.3.3
(function() {
  var CACHE, FileServer, PORT, fs, http, path, svr, url;

  PORT = 80;

  CACHE = {
    base: 'cache',
    packages: [
      {
        root: '/',
        "package": 'index.cache'
      }, {
        root: '/menuwiz/',
        "package": 'menuwiz.cache'
      }, {
        root: '/baeword/',
        "package": 'baeword.cache'
      }, {
        root: '/xmlcms/',
        "package": 'xmlcms.cache'
      }, {
        root: '/nav-sidebar/',
        "package": 'nav-sidebar.cache'
      }, {
        root: '/driver-asst/',
        "package": 'driver-asst.cache'
      }
    ]
  };

  fs = require('fs');

  path = require('path');

  http = require('http');

  url = require('url');

  FileServer = (function() {

    FileServer.create = function(ip, port) {
      return new this(ip, port);
    };

    function FileServer(ip, port) {
      var _this = this;
      this.ip = ip;
      this.port = port != null ? port : PORT;
      this.svr = http.createServer(this.routing.bind(this));
      this.load(function() {
        _this.svr.listen(_this.port, _this.ip);
        console.log("server listening on port " + _this.port + " ...");
      });
    }

    FileServer.prototype._load_caches = function(callback) {
      var _cache, _callback, _count,
        _this = this;
      _cache = this.cache = {};
      _count = CACHE.packages.length;
      _callback = function(err) {
        if (err) {
          console.log('err', err);
          callback(err);
        } else if (!--_count) {
          callback(null, _cache);
        }
      };
      CACHE.packages.forEach(function(cache) {
        var _pkg;
        _pkg = path.join(__dirname, CACHE.base, cache["package"]);
        return fs.readFile(_pkg, 'binary', function(err, data) {
          var filename, _file, _files, _i, _len, _path, _ref;
          if (err) {
            return _callback(err);
          }
          _files = _this._load_cache(new Buffer(data, 'binary'));
          _ref = Object.getOwnPropertyNames(_files);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            filename = _ref[_i];
            _path = cache.root + filename;
            _file = _cache[_path] = _files[filename];
            _file.path = _path;
            _file.filename = path.basename(_path);
          }
          console.log('cache', cache["package"], 'loaded');
          _callback(null);
        });
      });
    };

    FileServer.prototype._load_cache = function(buf) {
      var files, head, head_len, headers, name, offset, pad_char, pad_len, _get_data, _i, _len, _ref, _ref1;
      head_len = 1;
      pad_len = 16;
      pad_char = 0;
      while (buf[head_len]) {
        head_len++;
      }
      head = buf.toString('utf-8', 1, head_len);
      if ((buf[0] !== (_ref = buf[buf.length - 1]) || _ref !== pad_char)) {
        throw 'read package error: format padding mismatch';
      }
      try {
        head = JSON.parse(head);
      } catch (e) {
        throw 'cannot parse package';
      }
      if (head.v !== 2) {
        throw 'unacceptable package version ' + head.v;
      }
      offset = head_len + pad_len;
      if (buf[offset - 1] !== pad_char) {
        throw 'read package error: head padding mismatch';
      }
      _get_data = function(file) {
        var end;
        file.offset += offset;
        end = file.offset + file.length;
        if (buf[end] !== pad_char) {
          throw 'read package error: padding mismatch';
        }
        file.data = buf.slice(file.offset, end);
        delete file.offset;
      };
      if (Array.isArray(head.files)) {
        headers = head.files.shift();
        files = {};
        head.files.forEach(function(f) {
          var file, i, n, _i, _len;
          file = {};
          for (i = _i = 0, _len = headers.length; _i < _len; i = ++_i) {
            n = headers[i];
            file[n] = f[i];
          }
          file.mime = head.mimes[file.mime];
          _get_data(file);
          return files[file.filename] = file;
        });
      } else {
        files = head.files;
        _ref1 = Object.getOwnPropertyNames(files);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          _get_data(files[name]);
        }
      }
      return files;
    };

    FileServer.prototype.load = function(callback) {
      var _this = this;
      this._load_caches(function(err, cache) {
        if (err) {
          throw err;
        }
        console.log('init cache loaded');
        callback();
      });
    };

    FileServer.prototype.cmd = function(cmd, req, res) {
      res.setHeader('Cache-Control', 'no-cache');
      console.log('cmd', cmd);
      switch (cmd) {
        case '':
          res.writeHead(403, 'Forbidden');
          res.end("403 forbidden");
          break;
        case 'reload':
          this.load(function() {
            console.log('reloaded');
            return res.end('reloaded');
          });
          break;
        default:
          res.writeHead(501, 'Not Implemented');
          res.end("501 cmd '" + cmd + "' not implemented");
      }
    };

    FileServer.prototype.routing = function(req, res) {
      var cmd, _file, _url;
      if (!this.chkUA(req, res)) {
        return;
      }
      if (!this._chk_gz(req, res)) {
        return;
      }
      _url = url.parse(req.url);
      _file = _url.pathname;
      if (_file.slice(0, 3) === '/-/') {
        cmd = _file.slice(3);
        this.cmd(cmd, req, res);
        return;
      }
      if (/^\/[\w\-]+$/.test(_file)) {
        res.writeHead(301, {
          'Location': _file + '/'
        });
        res.end();
        return;
      }
      if (_file.slice(-1) === '/') {
        _file += 'index.html';
      }
      if (this.cache[_file]) {
        this.serve({
          url: _url.href,
          file: _file,
          caching: true,
          req: req,
          res: res
        });
      } else {
        res.writeHead(404, 'Not Found');
        res.end('404 resource not found');
      }
    };

    FileServer.prototype.chkUA = function(req, res) {
      var msg, ua;
      ua = req.headers['user-agent'];
      if (/MSIE [1-9]\./i.test(ua)) {
        msg = 'This WebApp does not support IE below 10!';
      } else if (/opera/i.test(ua)) {
        msg = 'This WebApp does not support Opera!';
      } else if (/^Mozilla\/4/i.test(ua)) {
        msg = 'This WebApp does not support your browser! \nIt seems your browser is out of date.';
      } else {
        return true;
      }
      res.end(msg);
      return false;
    };

    FileServer.prototype.MAX_AGE = 30 * 24 * 60 * 60 * 1000;

    FileServer.prototype.MIN_AGE = 60 * 1000;

    FileServer.prototype._chk_gz = function(req, res) {
      if (!/\bgzip\b/.test(req.headers['accept-encoding'])) {
        console.log('gzip unsupported for the client');
        res.writeHead(406, 'Not Acceptable');
        res.end('the client does not support gziped content (accept-encoding header).');
        return false;
      } else {
        return true;
      }
    };

    FileServer.prototype._chk_mod = function(url, file, req, res) {
      var _etag, _lastmod;
      _lastmod = req.headers['if-modified-since'];
      _etag = req.headers['if-none-match'];
      if (_lastmod && _etag && _etag === file._etag && file.mtime === new Date(_lastmod).getTime()) {
        console.log('304 served file not modified', url);
        res.writeHead(304, 'Not Modified');
        res.end();
        return false;
      } else {
        return true;
      }
    };

    FileServer.prototype.serve = function(_arg) {
      var caching, file, req, res, url, _caching, _expires, _file, _ref, _ref1;
      url = _arg.url, file = _arg.file, caching = _arg.caching, req = _arg.req, res = _arg.res;
      console.log('req:', req.connection.remoteAddress, req.url);
      if (!(_file = this.cache[file])) {
        throw 'failed to find the file ' + file;
      }
      if ((_ref = _file._mtime) == null) {
        _file._mtime = new Date(_file.mtime);
      }
      if ((_ref1 = _file._etag) == null) {
        _file._etag = "\"" + _file.size + "-" + _file.mtime + "\"";
      }
      if (!this._chk_mod(url, _file, req, res)) {
        return;
      }
      console.log('200 serve file:', file);
      _expires = caching ? _file.mtime + this.MAX_AGE : new Date().getTime() + this.MIN_AGE;
      _caching = caching ? this.MAX_AGE : this.MIN_AGE;
      res.setHeader('Content-Type', _file.mime);
      if (_file.gz) {
        res.setHeader('Content-Encoding', 'gzip');
      }
      res.setHeader('Vary', 'Accept-Encoding');
      res.setHeader('Content-Length', _file.data.length);
      res.setHeader('Last-Modified', _file._mtime.toUTCString());
      res.setHeader('Date', new Date().toUTCString());
      res.setHeader('Expires', new Date(_expires).toUTCString());
      res.setHeader('Cache-Control', 'public, max-age=' + (_caching / 1000) | 0);
      res.setHeader('ETag', _file._etag);
      res.end(_file.data, 'binary');
    };

    return FileServer;

  })();

  svr = FileServer.create();

}).call(this);
