// Generated by CoffeeScript 1.7.0
(function() {
  var CACHE, FileServer, IP, PORT, fs, http, path, svr, url, zlib,
    __hasProp = {}.hasOwnProperty;

  IP = null;

  PORT = 8080;

  CACHE = {
    base: 'cache',
    packages: [
      {
        root: '/',
        "package": 'index.cache'
      }, {
        root: '/marxo/',
        "package": 'marxo.cache',
        lazyload: true
      }, {
        root: '/menuwiz/',
        "package": 'menuwiz.cache',
        lazyload: true
      }, {
        root: '/baeword/',
        "package": 'baeword.cache',
        lazyload: true
      }, {
        root: '/xmlcms/',
        "package": 'xmlcms.cache',
        lazyload: true
      }, {
        root: '/nav-sidebar/',
        "package": 'nav-sidebar.cache',
        lazyload: true
      }, {
        root: '/driver-asst/',
        "package": 'driver-asst.cache',
        lazyload: true
      }
    ]
  };

  fs = require('fs');

  path = require('path');

  http = require('http');

  url = require('url');

  zlib = require('zlib');

  FileServer = (function() {
    FileServer.create = function(ip, port) {
      return new this(ip, port);
    };

    function FileServer(ip, port) {
      this.ip = ip != null ? ip : IP;
      this.port = port != null ? port : PORT;
      this.svr = http.createServer(this.routing.bind(this));
      this.load((function(_this) {
        return function() {
          _this.svr.listen(_this.port, _this.ip);
          console.log("server listening on port " + _this.port + " ...");
        };
      })(this));
    }

    FileServer.prototype._load_caches = function(lazy, callback) {
      var _cache, _count, _lazy;
      if (lazy == null) {
        lazy = true;
      }
      _cache = this.cache = {
        _lazyload: {}
      };
      _count = CACHE.packages.length;
      _lazy = _cache._lazyload;
      CACHE.packages.forEach((function(_this) {
        return function(cache) {
          if (!cache.root) {
            throw new Error('cache must have root');
          }
          if (lazy && cache.lazyload && cache.root !== '/') {
            _cache[cache.root.slice(0, -1)] = "301:" + cache.root;
            _lazy[cache.root] = cache;
            --_count;
          } else {
            _this._load_cache_pkg(cache, function(err) {
              if (err) {
                console.log('err', err);
                callback(err);
              } else if (!--_count) {
                callback(null, _cache);
              }
            });
          }
        };
      })(this));
      _cache._lazy_regex = new RegExp('^' + Object.keys(_lazy).join('|^'));
    };

    FileServer.prototype._lazyload = function(path, req, res) {
      var cache, _cache, _keys, _lazy, _ref, _root;
      _cache = this.cache;
      _lazy = _cache._lazyload;
      _root = _cache._lazy_regex && ((_ref = path.match(_cache._lazy_regex)) != null ? _ref[0] : void 0);
      if (_root) {
        cache = _lazy[_root];
        console.log('lazyload cache', cache["package"], 'for', _root);
        delete _lazy[_root];
        _keys = Object.keys(_lazy);
        if (_keys.length) {
          _cache._lazy_regex = new RegExp('^' + _keys.join('|^'));
        } else {
          this._lazyload = this._not_found.bind(this);
          delete _cache._lazy_regex;
        }
        this._load_cache_pkg(cache, (function(_this) {
          return function(err) {
            if (err) {
              console.log('err', err);
              res.writeHead(500, 'Internal Server Error');
              res.end('500 internal server error: faild to load package file');
            } else {
              _this.routing(req, res);
            }
          };
        })(this));
      } else {
        this._not_found(path, req, res);
      }
    };

    FileServer.prototype._load_cache_pkg = function(cache, callback) {
      var _cache, _pkg;
      _cache = this.cache;
      _pkg = path.join(__dirname, CACHE.base, cache["package"]);
      fs.readFile(_pkg, 'binary', (function(_this) {
        return function(err, data) {
          var filename, _dirname, _file, _filename, _files, _i, _len, _path, _ref;
          if (err) {
            return callback(err);
          }
          _files = _this._load_cache(new Buffer(data, 'binary'));
          _ref = Object.getOwnPropertyNames(_files);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            filename = _ref[_i];
            _path = cache.root + filename;
            _file = _cache[_path] = _files[filename];
            _file.path = _path;
            _filename = _file.filename = path.basename(_path);
            if (/^index\.html?$/i.test(_filename)) {
              _dirname = path.dirname(_path);
              if (_dirname === '/') {
                _cache['/'] = "/" + _filename;
              } else {
                _cache[_dirname] = "301:" + _dirname + "/";
                _cache[_dirname + '/'] = "" + _dirname + "/" + _filename;
              }
            }
          }
          console.log('cache', cache["package"], 'loaded');
          if (typeof gc === "function") {
            gc();
          }
          callback(null);
        };
      })(this));
    };

    FileServer.prototype._load_cache = function(buf) {
      var files, head, head_len, headers, name, offset, pad_char, pad_len, _get_data, _i, _len, _ref, _ref1;
      head_len = 1;
      pad_len = 16;
      pad_char = 0;
      while (buf[head_len]) {
        head_len++;
      }
      head = buf.toString('utf-8', 1, head_len);
      if ((buf[0] !== (_ref = buf[buf.length - 1]) || _ref !== pad_char)) {
        throw new Error('read package error: format padding mismatch');
      }
      try {
        head = JSON.parse(head);
      } catch (_error) {
        throw new Error('cannot parse package');
      }
      if (head.v !== 2) {
        throw new Error('unacceptable package version ' + head.v);
      }
      offset = head_len + pad_len;
      if (buf[offset - 1] !== pad_char) {
        throw new Error('read package error: head padding mismatch');
      }
      _get_data = function(file) {
        var end;
        file.offset += offset;
        end = file.offset + file.length;
        if (buf[end] !== pad_char) {
          throw new Error('read package error: padding mismatch');
        }
        file.data = buf.slice(file.offset, end);
        delete file.offset;
      };
      if (Array.isArray(head.files)) {
        headers = head.files.shift();
        files = {};
        head.files.forEach(function(f) {
          var file, i, n, _i, _len;
          file = {};
          for (i = _i = 0, _len = headers.length; _i < _len; i = ++_i) {
            n = headers[i];
            file[n] = f[i];
          }
          file.mime = head.mimes[file.mime];
          _get_data(file);
          return files[file.filename] = file;
        });
      } else {
        files = head.files;
        _ref1 = Object.getOwnPropertyNames(files);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          name = _ref1[_i];
          _get_data(files[name]);
        }
      }
      return files;
    };

    FileServer.prototype._not_found = function(path, req, res) {
      if (res == null) {
        res = req;
      }
      console.log('404 not found', path);
      res.writeHead(404, 'Not Found');
      res.end('404 resource not found');
    };

    FileServer.prototype.load = function(callback, full) {
      this._load_caches(!full, (function(_this) {
        return function(err, cache) {
          if (err) {
            throw new Error(err);
          }
          console.log('init cache loaded');
          callback();
        };
      })(this));
    };

    FileServer.prototype.cmd = function(cmd, req, res) {
      var cache, ignored, _count, _ref;
      res.setHeader('Cache-Control', 'no-cache');
      console.log('cmd', cmd);
      switch (cmd) {
        case '':
          res.writeHead(403, 'Forbidden');
          res.end("403 forbidden");
          break;
        case 'reload':
          this.load(function() {
            console.log('reloaded');
            return res.end('reloaded');
          });
          break;
        case 'full-reload':
          this.load(function() {
            console.log('full reloaded');
            return res.end('full reloaded');
          }, true);
          break;
        case 'full-load':
          _count = 0;
          _ref = this.cache._lazyload;
          for (ignored in _ref) {
            if (!__hasProp.call(_ref, ignored)) continue;
            cache = _ref[ignored];
            ++_count;
            this._load_cache_pkg(cache, (function(_this) {
              return function(err) {
                if (err) {
                  console.log('err', err);
                  res.end('faild to load package file');
                  _count = 0;
                } else if (!--_count) {
                  console.log('all loaded');
                  res.end('all loaded');
                }
              };
            })(this));
          }
          break;
        default:
          res.writeHead(501, 'Not Implemented');
          res.end("501 cmd '" + cmd + "' not implemented");
      }
    };

    FileServer.prototype.routing = function(req, res) {
      var cmd, _cached, _code, _file, _url;
      _url = url.parse(req.url);
      _file = _url.pathname;
      if (_file.slice(0, 3) === '/-/') {
        cmd = _file.slice(3);
        this.cmd(cmd, req, res);
        return;
      }
      _cached = this.cache[_file];
      while (typeof _cached === 'string') {
        if (/^30[1237]:/.test(_cached)) {
          _code = _cached.slice(0, 3);
          _cached = _cached.slice(4);
          console.log('redirect', _code, _file, '->', _cached);
          res.writeHead(_code, {
            'Location': _cached
          });
          res.end();
          return;
        } else {
          console.log('rewrite', _file, '->', _cached);
          _cached = this.cache[_file = _cached];
        }
      }
      if (!_cached) {
        this._lazyload(_file, req, res);
      } else {
        this.serve({
          url: _url.href,
          file: _file,
          caching: true,
          req: req,
          res: res
        });
      }
    };

    FileServer.prototype.MAX_AGE = 30 * 24 * 60 * 60 * 1000;

    FileServer.prototype.MIN_AGE = 60 * 1000;

    FileServer.prototype._chk_mod = function(url, file, req, res) {
      var _etag, _lastmod;
      _lastmod = req.headers['if-modified-since'];
      _etag = req.headers['if-none-match'];
      if (_lastmod && _etag && _etag === file._etag && file.mtime === new Date(_lastmod).getTime()) {
        console.log('304 served file not modified', url);
        res.writeHead(304, 'Not Modified');
        res.end();
        return false;
      } else {
        return true;
      }
    };

    FileServer.prototype.serve = function(_arg) {
      var caching, file, req, res, url, _accept_gz, _file;
      url = _arg.url, file = _arg.file, caching = _arg.caching, req = _arg.req, res = _arg.res;
      console.log('req:', req.connection.remoteAddress, req.url);
      if (!(_file = this.cache[file])) {
        throw new Error('failed to find the file ' + file);
      }
      if (_file._mtime == null) {
        _file._mtime = new Date(_file.mtime);
      }
      if (_file._etag == null) {
        _file._etag = "\"" + _file.size + "-" + _file.mtime + "\"";
      }
      if (!this._chk_mod(url, _file, req, res)) {
        return;
      }
      if (_file.caching === false) {
        caching = false;
      }
      _accept_gz = /\bgzip\b/.test(req.headers['accept-encoding']);
      if (_file.gz && !_accept_gz) {
        console.log('gzip unsupported for the client');
        if (_file._data != null) {
          this._serve_data(res, _file, caching, _accept_gz, _file._data);
        } else {
          zlib.gunzip(_file.data, (function(_this) {
            return function(err, _data) {
              if (err) {
                console.log('unzip failed', _file.filename);
                res.writeHead(406, 'Not Acceptable');
                res.end('unzip failed, and the client does not support gziped content (accept-encoding header).');
              } else {
                _file._data = _data;
                _this._serve_data(res, _file, caching, _accept_gz, _file._data);
              }
            };
          })(this));
        }
      } else {
        this._serve_data(res, _file, caching, _accept_gz, _file.data);
      }
    };

    FileServer.prototype._serve_data = function(res, file, caching, accept_gz, data) {
      var _caching, _expires;
      console.log('200 serve file:', file.filename);
      _expires = caching ? file.mtime + this.MAX_AGE : new Date().getTime() + this.MIN_AGE;
      _caching = caching ? this.MAX_AGE : this.MIN_AGE;
      res.setHeader('Content-Type', file.mime);
      res.setHeader('Vary', 'Accept-Encoding');
      res.setHeader('Last-Modified', file._mtime.toUTCString());
      res.setHeader('Expires', new Date(_expires).toUTCString());
      res.setHeader('Cache-Control', 'public, max-age=' + ((_caching / 1000) | 0));
      res.setHeader('ETag', file._etag);
      if (accept_gz && file.gz) {
        res.setHeader('Content-Encoding', 'gzip');
      }
      res.setHeader('Content-Length', data.length);
      res.end(data, 'binary');
    };

    return FileServer;

  })();

  svr = FileServer.create();

}).call(this);
